===================
>wicked filtercore<
===================

_filterCore is the focal point of an  IMacroFilter object; it
executes the rendering of links on every wicked link found in
a block of filtered text. 

In wicked,  alone does nothing. All behavior is derived form stacked
decorators (see 'decorator_intro.txt' for further explanation of
decorators).  The stacked decorators act as a pipeline processing
input. These functions and stacked combinations are reused elsewhere
in wicked. 

In _filtercore, the chained behavior is broken into a X step
sequence. The filtercore module holds the non-platform specific
elements of this logic (current rendering is zope specific).

This document will test each of those found in the
module in the sequence that data passes through
them, from call to return.

Note: this is the opposite of the
order that decorators are applied to create _filtercore, and
is an arbitrary design decision to use decorators to create
a switching pattern, not a restriction of the decorator pattern.

First, we need to load up some stubs for our tests. 

    >>> from testing.filtercore import dummy, \
    ... fakecacheiface, fakefilter
    >>> from filtercore import onlybrain, setup, cache, query

I. setup
========


Setup handles normalizing the input.  The normalize input will act
as the primary key for retrieving any data, cached or otherwhise.

Create a simple stand-in for _filtercore::

    >>> def _filtercore(f, chunk, norm, **kwargs):
    ...     return chunk, norm, f.has

decorate, call, test::
    
    >>> fc = setup(_filtercore)
    >>> values = fc(fakefilter(), 'my wicked link', **dict(has='a value'))

chunk should be unaltered

    >>> values[0]
    'my wicked link'

make sure it's normalized::

    >>> values[1]
    'my-wicked-link'

    >>> values[2]
    'a value'

II. cache
=========

Check for cached data.  if found, return. If not, run the stack and stuff
result in the cache.  'cache' is the only decorator that executes
behavior before and after the method it wraps.

Currently, the cache returns rendered data. This will be refactored to return 
some sort of renderable data object.

'cache' can take the argument iface to manual set the cache
management interface for testing purposes.

First we define a surrogate that will simulate current behavior
of the stack beneath cache::

    >>> def _filtercore(f, chunk, norm, **kwargs):
    ...     uid = norm
    ...     if kwargs.get('return_brain'):
    ...         return 'brains!'
    ...     return uid, '$$' + norm

We'll use a dictionary as our cache::

    >>> fcache = {'bl-ah':'blah.txt'}
    >>> _filtercore = cache(_filtercore, iface=fakecacheiface(fcache))
    >>> wfilter = fakefilter()

Data objects returned by a query should get passes
through with the brain flag::

    >>> _filtercore(wfilter, 'dud', 'dud dud dud', return_brain=True)
    'brains!'
    
A set should return rendered text::

    >>> _filtercore(wfilter, "hello darlin\'", 'hello-darlin')
    'http://fakeurl/hello-darlin'

lets decorate our original cache from 'setup'
and hit the cache with some normalled text::


    >>> _filtercore = setup(_filtercore)
    >>> _filtercore(wfilter, 'bl ah', **dict(hello=True))
    'blah.txt'


III. query & match
==================

- query: 

    returns 0-N data-objects based on the chunk and
    whatever query component is used.

    Produces a method that returns either the brain or
    the uid and the rendered link for an unrendered link

    - match:

        Reduces the query results to 0-N results returned.

	Currently, match is implemented a limiting decorator
	on the query implementation(see factories.py)

Essentially, query is a logic switch: it gets a query object
implementing IWickedQuery (called a seeker) from the filter
and makes it perform a search. if that search fails,
query uses the object to perform a scoped search.

first, set up our surrogates::

    >>> def _filtercore(f, chunk, brains, **kwargs):
    ...     return brains

The fakefilter has it's own stub query object.
see testing/filtercore.py:: 

    >>> wfilter = fakefilter()
    >>> _filtercore = query(_filtercore)

Look for something not there::

    >>> _filtercore(wfilter, 'dud', 'blah')

Look for something that is there::

    >>> _filtercore(wfilter, 'findme', 'blah')
    ['We are brains!']

Look for something that is scoped::

    >>> _filtercore(fakefilter(), 'scoped', 'blah')
    ['We are brains!']

Test with top of stack('setup' & 'cache')::

    >>> fcache = {'bl-ah':'blah.txt'}
    >>> _filtercore = setup(cache(_filtercore, iface=fakecacheiface(fcache)))
    >>> _filtercore(wfilter, 'Bab bam')
    ['We are brains!']

    Will hit cache
    >>> _filtercore(wfilter, 'bl ah')
    'blah.txt'
      
IV. render
==========

Currently, this step is dependent on the zope2 templating
engine, but will be extend to use other engines.

